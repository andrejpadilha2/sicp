### Structure and Interpretation of Computer Programs

Procurando referências para aprender Ciência da Computação com mais rigor/profundidade, acabei encontrando o site https://teachyourselfcs.com/ e foi daqueles sites que salvei no favorito e sempre dou umas olhadinhas nas referências de lá, embora seja super curtinho.

Iniciei minha jornada pelo primeiro tópico, "Programação", com o livro "Structure and Interpretation of Computer Programs" (SICP). Li, assisti aulas e resolvi mais de 300 exercícios (estes aqui!) por conta própria em um período de aproximadamente 5 meses.

E minha mente realmente deu uma explodida lendo este livro. 

Durante a vida universitária nós estudamos com muitos livros, lemos muitas coisas, resolvemos muitos exercícios, mas sempre tem algo que se destaca do restante, talvez por termos tido um bom professor ou talvez pelo livro em si ser muito bom. Como li o livro por conta (tive o apoio das aulas online do Professor Brian Harvey), é o caso da segunda opção.

Primeiro que o livro passou obviamente pelo teste do tempo: primeira edição em 1984, segunda edição em 1996. Isso é algo que vem me convencendo mais e mais ultimamente. Coisas que são úteis em qualquer época sem precisar de buzzwords ou apelo financeiro (“{leia este livro}/{faça este curso} e aumente seu salário em até 100%”).

Segundo que o livro trata de algo ainda um passo antes de algoritmos: linguagens de programação no geral. Me convenci particularmente por conta da seguinte passagem:

Why? Because SICP is unique in its ability — at least potentially — to alter your fundamental beliefs about computers and programming. Not everybody will experience this. Some will hate the book, others won’t get past the first few pages. But the potential reward makes it worth trying.

E realmente valeu a pena.

Para ser bem honesto com o livro e explicar realmente o quão impressionante ele é, eu teria que copiar todas as palavras dele aqui, o que me daria um Copyright Infringement. Sigo com minhas palavras, definitivamente piores que as dos autores de SICP.

Vou deixar aqui algumas das ideias mais legais que vi no livro:

- Abstração, abstração, abstração: rapidamente percebemos que programas de computador crescem muito rapidamente. Usamos abstrações SEMPRE que podemos para não pensar no programa em termos do que o computador nos oferece, e sim no problema que queremos resolver.
- First-class procedures: os procedimentos (procedures) podem ser tratados como um DADO, ou seja, podem ser passados como argumentos para outros procedimentos, retornados de procedimentos, nomeados ou agregados (como em um par), i.e., podem ser cidadãos de primeira classe. (inserir exemplo simples).
- Por outro lado, dados podem ser tratados como PROCEDIMENTOS: Quando definimos o que é um par (um agregado de 2 “coisas”), a construção e seleção dos elementos desses pares não precisam ser algo “mágico” dado pela linguagem. Eles podem ser (e são) implementados como procedimentos!
- De 2 e 3 ganhamos que: realmente não há divisão entre o que são dados e o que é código. Dados são códigos, e códigos são dados.
- Recursão: isso aparece inúmeras vezes no livro, muitas vezes disfarçado, muitas vezes bem explícito. Porém fica muito mais interessante quando aprendemos sobre interpretadores e compiladores nos capítulos finais. Tem inclusive uma nota de rodapé que apresenta muito naturalmente o Y-Combinator para mostrar como implementar recursão em uma linguagem que não suporta recursão naturalmente, usando apenas cálculo lambda. É de arrepiar.
- Cálculo lambda: o livro definitivamente não trata sobre isso especificamente, mas foi meu primeiro contato com o tema, e senti que implementar o Y-Combinator no papel foi muito legal.
- Normal order, applicative order e environment model of evaluation.
- Paradigmas de programação: programação funcional, programação orientada à objetos e programação declarativa. O mais legal é que você começa utilizando programação funcional e o livro explica o conceito de environments ao mesmo tempo que utiliza pela primeira vez os conceitos de local state com procedimentos como “set!” no capítulo 3 para alterar o estado de uma variável (até então nada tinha utilizado estados mutáveis). Quando você se dá conta não só utilizou a programação orientada à objetos (OOP), e sim criou uma versão da linguagem que aceita OOP por conta própria, basicamente do zero (utiliza aqui o poder dos first-class procedures).
- Programação funcional: assim como em uma função matemática, para entradas iguais em seu procedimento (ou seja, utilizando exatamente os mesmo argumentos) a saída também deve ser a mesma, sempre.
- Programação orientada à objetos: apenas no terceiro capítulo que temos bagagem suficiente para implementar uma linguagem orientada à objetos, e isso só é possível depois de termos visto técnicas como message passing, local state e inheritance. Fica muito mais claro entender esse paradigma de programação quando entendemos bem a noção de local state e environments (inclusive fazendo inúmeros desenhos de environments na resolução dos exercícios).
- Paralelismo: introduz diversos problemas que surgem quando temos vários processadores dividindo os mesmos recursos (dados), ou vários inputs/outputs em um sistema operacional, e alguns dos mecanismos utilizados para contornar esses problemas: operações atômicas (que consultam E alteram o estado de uma variável em uma mesma instrução do processador), o mutex (que define quais são as seções críticas do código, ou seja, as que não podem ser interrompidas pois acabam gerando erros no estado das variáveis, e esses erros são muito difíceis de detectar pois não dão nenhum tipo de aviso) e os serializers que garantem que dois procedimentos que usam os mesmos recursos não terão suas instruções intercaladas, gerando erros.
- Deadlock: em processos que dividem os mesmos recursos (por exemplo, realizar duas transferências bancárias, de A para B enquanto outra pessoa realiza de B para A, necessitando consultar o saldo bancário das duas contas), é capaz que os dois processos fiquem em um impasse pois cada um deles necessita consultar/alterar um recurso que está “protegido” pelo outro processo (o processo 1 capturou e protegeu o estado do saldo bancário da conta A, enquanto o processo 2 capturou e protegeu o estado do saldo bancário da conta B; quando o processo 1 tentar capturar o estado do saldo bancário da conta B, não irá conseguir pois ele está protegido pelo processo 2, e quando o processo 2 tentar capturar o estado do saldo bancário da conta B, não irá conseguir pois está protegido pelo processo 1). Há diversas técnicas para evitar deadlocks (como por exemplo numerar os recursos e especificar que eles devem ser capturados sempre começando pelo menor número, assim evitaríamos o problema descrito acima).
- Streams: são introduzidos como uma nova estrutura de dados, com uma grande vantagem em relação às variáveis com estado mutável: conseguem representar sequências infinitas (essa foi a primeira parte que fiquei realmente encantado lendo este livro). Em um par normal, temos o primeiro elemento do par (car) e o segundo elemento (cdr). Em uma stream também temos isso, porém o segundo elemento é uma promessa de computar o restante dos termos, ou seja, eles não são computados na hora (há literalmente um delay e esse termo só é computado quando invocamos o procedimento force). Assim, conseguimos algumas vantagens: podemos ter um procedimento que é mais claro/fácil de ler e ainda assim eficiente computacionalmente (exemplo).
- Memoização: em algoritmos, quando utilizamos uma recursão, às vezes calculamos o mesmo subproblema diversas vezes, e isso pode ser evitado salvando esse valor já calculado em uma tabela. Basicamente “programação dinâmica” é o uso de “divisão e conquista” + “memoização”. O livro não fala especificamente da técnica de “divisão e conquista”, mas a usa inúmeras vezes.
- Interpretadores: nos capítulos 4 e 5 começamos a aprender sobre os evaluators, como o código que escrevemos é interpretado pela máquina, “quem” faz isso, “como” faz isso. Entendemos que o evaluator para uma linguagem de programação é ele mesmo um outro programa, e que na verdade podemos escrever um evaluator de uma certa linguagem utilizando aquela mesma linguagem. No livro tudo isso é utilizado para criar novas linguagens, com funções e objetivos bem diferentes da linguagem original que estávamos utilizando, mais adequadas para os problemas que queremos resolver. Inclusive o livro diz que esta é a ideia mais fundamental em programação: “The evaluator, which determines the meaning of expressions in a programming language, is just another program.”
- Compiladores: diferente dos interpretadores (que “eleva” a linguagem da máquina para a linguagem que estamos usando para programar), a estratégia de compilação “abaixa” a linguagem que estamos usando para programar para o nível da linguagem da máquina. Dessa maneira diversas otimizações no código que irá ser executado na máquina podem ser feitas, tipicamente aumentando a velocidade dos códigos. Porém confesso que ainda preciso estudar este tema para entender melhor.

Acho que o principal é entender que as linguagens de programação servem para que os programas que escrevemos reflitam o problema que estamos tratando e não como os computadores funcionam.

### Outras avaliações
Para complementar, algumas outras avaliações sobre o SICP:

*SICP was revolutionary in many different ways. Most importantly, it dramatically raised the bar for the intellectual content of introductory computer science. Before SICP, the first CS course was almost always entirely filled with learning the details of some programming language. SICP is about standing back from the details to learn big-picture ways to think about the programming process. It focused attention on the central idea of abstraction - finding general patterns from specific problems and building software tools that embody each pattern.* http://people.eecs.berkeley.edu/~bh/sicp.html#:~:text=SICP%20is%20about%20standing%20back,tools%20that%20embody%20each%20pattern.

https://www.quora.com/Whats-so-great-about-SICP

https://www.youtube.com/watch?v=Z0VpFmp_q4A
